#-----------------------------------------------------------------------------
# Structure of a BASH utility file:
# 1. Each utility file should be named util_<name>.sh
# 2. First line must check if bu.sh is loaded
#----------------------------------------------------------
# File: bu/BU_GUIDE
# Author: Bazinga Labs LLC
# Email:  support@bazinga-labs.com
# ==============================================================================
# DO NOT MODIFY THIS FILE WITHOUT PRIOR AUTHORIZATION
#
# This file is managed by Bazinga Labs LLC and changes may be overwritten.
# Unauthorized edits may result in system malfunction or integration failure.
# Contact support@bazinga-labs.com for changes or exceptions.
# ==============================================================================

-----------------------------------------------------------------------------
BASH UTILITY CREATION GUIDE
-----------------------------------------------------------------------------

Structure of a BASH utility file:
1. Each utility file should be named util_<name>.sh
2. First line must check if util_bash.sh is loaded
3. Each function should follow the format: function_name() { Description
4. Use err, warn, and info functions for consistent output

Example template for a new utility file:

#-----------------------------------------------------------------------------
#!/bin/env bash
# Ensure proper Bash Utilities environment
#-----------------------------------------------------------------------------
# Ensure proper Bash Utilities environment
if ! type info &>/dev/null; then
    echo "ERROR: bu.sh is not loaded. Please source bu.sh first."
    return 1 2>/dev/null || exit 1
fi
# Ensure this file is sourced, not executed
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "ERROR: This script should be sourced, not executed."
    echo "Usage: source ${BASH_SOURCE[0]}"
    exit 1
fi
#-----------------------------------------------------------------------------
# Functions that are named <utilname>_<functionality>
my_function() { # Description of what this function does
  # Function implementation
  if [ -z "$1" ]; then
    info "Usage: my_function <parameter>"
    warn "Parameter is required"
    return 1
  fi
  # Logic with proper error handling
  if ! command_that_might_fail; then
    err "Something went wrong"
    return 1
  fi
  # info "Operation completed successfully"
  return 0
}
#-----------------------------------------------------------------------------
# Create aliases if needed
alias my_alias='my_function'
#-----------------------------------------------------------------------------
 
Best practices:
1. Include header with file name, author, and description
2. Add horizontal lines (-------------) between functions for readability
3. Document function parameters in the function body
4. Use return codes: 0 for success, non-zero for errors
5. Create backward-compatible aliases when renaming functions
6. Test for requirements before performing operations
7. Keep functions focused on a single responsibility